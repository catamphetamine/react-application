import { createStore, combineReducers, applyMiddleware, compose } from 'redux'
import { composeWithDevToolsLogOnlyInProduction as composeWithDevTools } from '@redux-devtools/extension'

import asynchronousMiddleware from './middleware/asynchronous.js'
import routerMiddleware from './middleware/router.js'

import reactPagesReducer from './reducer.js'

import { REDUCER_NAME, PAGE_STATE_REDUCER_NAME_PREFIX } from './constants.js'

import { checkForAutogeneratedEventNameCollision } from './naming.js'

import validateRoutes from '../router/validateRoutes.js'
import createGetDataFunctionsForRoutes from './createGetDataFunctionsForRoutes.js'
import createRenderFunctionsForRoutes from './createRenderFunctionsForRoutes.js'

import {
	foundReducer,
	createRouterStoreEnhancers
} from '../router/index.js'

import {
	initializeRouterAction
} from '../router/actions.js'

export default function _createStore({
	initialState: data,
	createHistoryProtocol,
	httpClient,
	stash,
	settings,
	options
}) {
	let {
		reducers
	} = settings

	const {
		routes,
		pageStateReducerNames,
		reduxMiddleware,
		reduxStoreEnhancers,
		reduxEventNaming,
		http,
		onLoadError,
		getLocale,
		codeSplit,
		load
	} = settings

	const {
		server,
		devtools,
		stats,
		context,
		onBeforeNavigate,
		onNavigationFinished,
		getCookie
	} = options

	validateRoutes(routes)

	reducers = markPageStateReducers(reducers, pageStateReducerNames)

	createGetDataFunctionsForRoutes(routes, {
		stash,
		codeSplit,
		server,
		onLoadError,
		getLocale,
		getCookie,
		context
	})

	createRenderFunctionsForRoutes(routes, {
		stash,
		codeSplit,
		server
	})

	// Redux middleware.
	const middleware = []

	// Built-in middleware.
	middleware.push(
		// Asynchronous middleware (e.g. for HTTP Ajax calls).
		asynchronousMiddleware({
			httpClient,
			reduxEventNaming,
			server,
			onError: http.onError,
			getErrorData: http.getErrorData
		})
	)

	if (!server) {
		middleware.push(routerMiddleware({
			routes,
			codeSplit,
			onBeforeNavigate,
			onNavigationFinished,
			reportStats: stats,
			context,
			stash
		}))
	}

	// Redux "store enhancers"
	const storeEnhancers = []

	// Add custom Redux middleware to store "enhancers".
	// Developers may supply their own ("custom") Redux middleware.
	//
	// Custom Redux middleware should be added to the start of the "enhancers" chain.
	// Otherwise, `dispatch(redirect(...))` from custom middleware won't work
	// because `farce`'s "enhancer" wouldn't "see" any actions dispatched from custom middleware.
	// https://github.com/reduxjs/redux/issues/1051
	//
	// Redux middleware are applied in reverse order relative to how they're passed
	// to `applyMiddleware()` function (which is counter-intuitive).
	// https://stackoverflow.com/questions/44342948/why-were-doing-slice-reverse-in-redux-applymiddleware-function
	//
	if (reduxMiddleware) {
		storeEnhancers.push(applyMiddleware(...getPropertyFromPropertyOrPropertyGetter(reduxMiddleware)))
	}

	// User may supply his own Redux store enhancers.
	if (reduxStoreEnhancers) {
		storeEnhancers.push(...getPropertyFromPropertyOrPropertyGetter(reduxStoreEnhancers))
	}

	storeEnhancers.push(...createRouterStoreEnhancers(routes, createHistoryProtocol, {
		basename: settings.basename
	}))

	// Add Redux middleware to store "enhancers".
	//
	// Redux middleware are applied in reverse order relative to how they're passed
	// to `applyMiddleware()` function (which is counter-intuitive).
	// https://stackoverflow.com/questions/44342948/why-were-doing-slice-reverse-in-redux-applymiddleware-function
	//
	storeEnhancers.push(applyMiddleware(...middleware))

	// Create Redux store.
	const store = getStoreEnhancersComposer(server, devtools)(...storeEnhancers)(createStore)(createReducer(reducers), data)

	// On the client side, add `hotReload()` function to the `store`.
	// (could just add this function to `window` but adding it to the `store` fits more)
	if (!server) {
		// `hotReload` helper function gives the web application means to hot reload its Redux reducers
		store.hotReload = (reducers) => store.replaceReducer(createReducer(reducers))
	}

	// Initialize `found`.
	store.dispatch(initializeRouterAction())

	// Return the Redux store
	return store
}

function createReducer(reducers) {
	// Check for reserved reducer names.
	for (const reducerName of RESERVED_REDUCER_NAMES) {
		if (reducers[reducerName]) {
			throw new Error(`"${reducerName}" reducer name is reserved.`)
		}
	}
	// Check for `ReduxModule` autogenerated event names conflicts.
	checkForAutogeneratedEventNameCollision(reducers)
	// Clone the object because it will be modified.
	reducers = { ...reducers }
	// Add router reducer.
	reducers[ROUTER_REDUCER_NAME] = foundReducer
	// Add `react-pages` reducer.
	reducers[REDUCER_NAME] = reactPagesReducer
	// Create the combined reducer.
	return combineReducers(reducers)
}

function getStoreEnhancersComposer(server, devtools) {
	// Redux DevTools aren't used on the server side
	if (server) {
		return compose
	}

	// Custom behaviour
	if (devtools && devtools.compose) {
		return devtools.compose(devtools.options)
	}

	// With custom options
	if (devtools && devtools.options) {
		return composeWithDevTools(devtools.options)
	}

	// Without custom options
	return composeWithDevTools
}

// `found` router library stores its state in "found" property of Redux state.
export const ROUTER_REDUCER_NAME = 'found'

// `farce` history management library stores its state in "location" property of Redux state.
const HISTORY_REDUCER_NAME = 'location'

const RESERVED_REDUCER_NAMES = [
	REDUCER_NAME,
	ROUTER_REDUCER_NAME,
	HISTORY_REDUCER_NAME
]

// Supports legacy ways of passing `reduxMiddleware` or `reduxStoreEnhancers`
// when those two could be functions returning arrays rather than just arrays.
function getPropertyFromPropertyOrPropertyGetter(property) {
	if (typeof property === 'function') {
		return property()
	} else {
		return property
	}
}

function markPageStateReducers(reducers, pageStateReducerNames) {
	const newReducers = {}

	for (const key of Object.keys(reducers)) {
		if (pageStateReducerNames && pageStateReducerNames.indexOf(key) >= 0) {
			newReducers[PAGE_STATE_REDUCER_NAME_PREFIX + key] = reducers[key]
		} else {
			newReducers[key] = reducers[key]
		}
	}

	return newReducers
}